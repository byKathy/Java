#04.创建和启动Java线程

Java线程对象与其它的对象相似。线程对象是`java.lang.Thread`的实例，或是`java.lang.Thread`的子类的实例。跟普通对象不同，线程对象可以执行代码。

##创建和启动线程（Creating and Starting Threads）

在Java中，可以使用以下方式创建线程：

```Java
Thread thread = new Thread();
```

调用`Thread.start()`可以启动线程：

```Java
thread.start();
```

这个例子并没有为线程指定要执行的代码，所以它会很快返回并停止。

有两种方法可以为线程指定需要执行的代码。第一种方式是创建`Thread`的子类并重写`run()`方法；第二种方式是将实现`Runnable`接口的对象作为构造参数传给`Thread(Runnale r)`。

##继承Thread类（Thread Subclass）

第一种为线程指定执行代码的方法：**继承Thread类并重写run方法。**  `run()`方法在调用`Thread.start()`后执行。例子：

```Java
public class MyThread extends Thread {
  public void run(){
     System.out.println("MyThread running");
  }
}
```

通过下面的代码创建并执行线程：

```
  MyThread myThread = new MyThread();
  myTread.start();
```

`start()`方法的调用会立即返回，并不会等待`run()`方法的执行，就好像这段代码被其他的CPU执行一样。

你还可以使用匿名子类来创建线程对象：

```Java
Thread thread = new Thread(){
  public void run(){
    System.out.println("Thread Running");
  }
}

thread.start();
```

##实现Runnable接口（Runnable Interface Implemention）

第二种为线程指定执行代码的方法：创建实现`java.lang.Runnable`接口的对象，然后把该对象交给Thread执行。

MyRunnable类实现Runnable接口：

```Java
public class MyRunnable implements Runnable {
  public void run(){
     System.out.println("MyRunnable running");
  }
}
```

将MyRunnable的实例作为构造参数传给Thread，然后通过`thread.start()`启动线程：

```Java
Thread thread = new Thread(new MyRunnable());
thread.start();
```

当线程启动后，它会调用MyRunnable实例的`run()` 方法而不是自身的`run()`方法。


同样，你可以通过匿名Runnable类来实现：

````Java
Runnable myRunnable = new Runnable(){

	 public void run(){
		System.out.println("Runnable running");
	 }
}

Thread thread = new Thread(myRunnable);
thread.start();
```

##子类还是实现接口（Subclass or Runnable）?

There are no rules about which of the two methods that is the best. Both methods works. Personally though, I prefer implementing Runnable, and handing an instance of the implementation to a Thread instance. When having the Runnable's executed by a thread pool it is easy to queue up the Runnable instances until a thread from the pool is idle. This is a little harder to do with Thread subclasses.

Sometimes you may have to implement Runnable as well as subclass Thread. For instance, if creating a subclass of Thread that can execute more than one Runnable. This is typically the case when implementing a thread pool. ??? Thread本身已经实现Runnable接口，这段话如何理解？？

##常见陷阱：（Common Pitfall: Calling run() instead of start()）

一个常见的陷阱就是调用`run()`方法来启动线程：

```Java
Thread newThread = new Thread(MyRunnable());
thread.run();  //should be start();
```



At first you may not notice anything because the Runnable's run() method is executed like you expected. However, it is NOT executed by the new thread you just created. Instead the run() method is executed by the thread that created the thread. In other words, the thread that executed the above two lines of code. To have the run() method of the MyRunnable instance called by the new created thread, newThread, you MUST call the newThread.start() method.

##线程名称（Thread Names）

When you create a thread you can give it a name. The name can help you distinguish different threads from each other. For instance, if multiple threads write to System.out it can be handy to see which thread wrote the text. Here is an example:

```Java
Thread thread = new Thread("New Thread") {
   public void run(){
     System.out.println("run by: " + getname());
   }
};

thread.start();
System.out.println(thread.getName());
```

Notice the string "New Thread" passed as parameter to the Thread constructor. This string is the name of the thread. The name can be obtained by the Thread's getName() method. You can also pass a name to a Thread when using a Runnable implementation. Here is how that looks:

```Java
MyRunnable runnable = new MyRunnable();
Thread thread = new Thread(runnable, "New Thread");

thread.start();
System.out.println(thread.getName());
```
Notice however, that since the MyRunnable class is not a subclass of Thread, it does not have access to the getName() method of the thread executing it. A reference to the currently executing thread can be obtained using the call

```Java
Thread.currentThread();
```

Getting the name of the thread currently executing the code can therefore be done like this:

```Java
String threadName = Thread.currentThread().getName();
```
##Java线程示例（Java Thread Example）

Here is a small example. First it prints out the name of the thread executing the main() method. This thread is assigned by the JVM. Then it starts up 10 threads and give them all a number as name ("" + i). Each thread then prints its name out, and then stops executing.

```Java
public class ThreadExample {

  public static void main(String[] args){
    System.out.println(Thread.currentThread().getName());
    for(int i=0; i<10; i++){
      new Thread("" + i){
        public void run(){
          System.out.println("Thread: " + getName() + " running");
        }
      }.start();
    }
  }
}
```

Note that even if the threads are started in sequence (1, 2, 3 etc.) they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out. This is because the threads are in principle executing in parallel and not sequentially. The JVM and/or operating system determines the order in which the threads are executed. This order does not have to be the same order in which they were started.