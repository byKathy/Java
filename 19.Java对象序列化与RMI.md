#19.Java对象序列化与RMI

##19.1 Java对象序列化

对于一个存在于Java虚拟机中的对象来说，其内部的状态只保持在内存中。JVM停止之后，这些状态就丢失了。在很多应用场景中，很有必要将对象的内部状态持久化下来。

例如，用户A登陆了某系统，然后Tomcat被运维人员重启，而此时用户A的登陆凭证并没有因此丢失，这就是对象序列化发挥了作用：Tomcat在完成停止动作之前，将内部的登陆凭证数据序列化到硬盘中，然后在启动时重新读取这部分数据，登陆凭证并没有因容器重启而丢失。

###19.1.1 序列化

__对象序列化：将对象的状态信息转换为可以存储或传输的形式的过程。__

在Java中，并不是所有的对象都可以进行序列化，__只有实现`Serializable`接口的对象才可以进行序列化__。`Serializable`与`Cloneable`一样只是一个标识接口（markable interface），没有任何方法的定义，只标识实现此接口的对象拥有某些行为。

对象的序列化实际上通过类`ObjectOuputStream`类来完成。如：

```Java
public class serializableTest {
	@Test
	public void serialize() throws IOException, ClassNotFoundException {
		FileOutputStream fos = new FileOutputStream(new File("c://person.ser"));
		ObjectOutputStream oos = new ObjectOutputStream(fos);

		oos.writeObject(new Person("cokepluscarbon")); // 序列化person对象到硬盘中
		oos.close();
	}
}

class Person implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;

	public Person(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
```

需要注意：
 * 如果对象person没有实现`Serializable`接口，则会抛出`NotSerializableException`异常；
 * 序列化实际上是序列化整个对象图，例如Person对象引用了Country对象，则Country对象也需要实现`Serializable`接口；否则序列化过程失败；
 * 默认情况下，Java对象的非静态域才会参与序列化；如果想要排除某个域，可以使用注释`@transient`来排除，或使用域`serialPersistentFields`来指定需要序列化的域；

###19.1.2 反序列化

__反序列化：与序列化相反，发序列化用于将存储于介质的数据反序列化为对象。__

反序列化过程使用__ObjectInputStream__进行实现。例如将person.ser反序列化成person对象：

```Java
@Test
public void deserialize() throws IOException, ClassNotFoundException {
	FileInputStream fis = new FileInputStream(new File("c://person.ser"));
	ObjectInputStream ois = new ObjectInputStream(fis);

	Person person = (Person) ois.readObject();
	ois.close();

	System.out.println(person.getName()); // cokepluscarbon
}
```

###19.1.3 自定义对象序列化

###19.1.4 序列化版本号

###19.1.5 序列号安全

##19.2 远程调用RMI

##19.3 参考资料
* 《Java深度历险》
* 《Java_编写高质量代码：改善Java程序的151个建议》
* http://stackoverflow.com/questions/1746550/purpose-of-serialization-in-webapplication
