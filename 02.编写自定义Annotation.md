#02.编写自定义Annotation

Annotation在一些框架中经常被用到，例如JPA中的@Table、@Column，Spring中的@Controller、@Service、@Depository等。与Java的传统
的Annotation不同的时，这些Annotation往往被赋予一些'类似编码'和配置的作用。例如@Inject，可以用于注入。Annotation的引入大大减少了
Java的编码量和配置的复杂度。

##1.编写简单的Annotation

编写一个Annotation，需要用到一个接口注释 **@Interface** 来修饰这是一个Annotation接口，同时在该接口中使用**@Retention**和**@Target**来设置
该Annotation接口的保留级别和注解目标。
  
    @Target(value = ElementType.METHOD)  // 表明这个一个用在方法上的Annotation
    @Retention(value = RetentionPolicy.RUNTIME)  // 表明该注释的保留级别为运行时
    public @interface TestCase {  // 使用@Interface修饰这个是一个Annotation接口

    }

以上就完成了一个Annotation接口的编写。接着我们写一个Test类来使用@TestCase这个注释。

    public class Test {
      @TestCase
      public void m_1(){
      	System.out.println("This is Method with @TestCase!");
      }
      
      @TestCase
      public void m_2(){
      	System.out.println("This is Method without @TestCase!");
      }
    }

  

要让一个Annotation接口具有类似编码和配置的能力，单靠Annotation是无法完成的，我们需要借助Java的 **反射机制** 的能力。这样我们就
可以在程序运行过程中，取得Annotation的内容，然后根据配置进行具体的操作。下面这个程序就是编写一个主方法，然后找出被@TestCase
注解的方法，然后调用该方法。

	public class TestAnnotation {
		public static void main(String[] args) {
		
			Test test = new Test();
			Method[] methods = test.getClass().getMethods();  // 取得该class的所有方法
		
			for (Method method : methods) {
				TestCase ts = method.getAnnotation(TestCase.class);  // 判断该方法是否被@TestCase注解，如果没有，则ts为null
				if (ts != null) {
					try {
						method.invoke(test);  // 如果ts不为null，则调用该方法
					} catch(Exception e) {
						// 为了方便不作处理
					}
				}
			}
		}
	}
		
运行上面这个程序，结果毫无疑问地打印 **This is Method with @TestCase!** 。

























