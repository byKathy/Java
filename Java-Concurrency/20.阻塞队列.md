#20.阻塞队列

**阻塞队列**是这样一种队列：当队列为空时**出列（dequeue）**会阻塞，当队列满时**入队**会阻塞。当一个线程试图从一个空队列出列就会进入阻塞，直到其他线程将元素入列；当一个线程试图从一个满的队列中入列也会阻塞，直到其他线程将对队列中的元素出列或者将队列清空。

下面的图展示了两个线程如何跟阻塞队列进行交互：


![A BlockingQueue with one thread putting into it, and another thread taking from it.](http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png)

Java 5的`java.util.concurrent`包中引入了阻塞队列的实现。即使如此，了解底层的实现原理也是非常有必要和有帮助的。

##阻塞队列的实现（Blocking Queue Implementation）

 **阻塞队列**的实现跟**有界信号量**的实现类似。下面是一个阻塞队列的实现：

```Java
public class BlockingQueue {

  private List queue = new LinkedList();
  private int  limit = 10;

  public BlockingQueue(int limit){
    this.limit = limit;
  }


  public synchronized void enqueue(Object item)
  throws InterruptedException  {
    while(this.queue.size() == this.limit) {
      wait();
    }
    if(this.queue.size() == 0) {
      notifyAll();
    }
    this.queue.add(item);
  }


  public synchronized Object dequeue()
  throws InterruptedException{
    while(this.queue.size() == 0){
      wait();
    }
    if(this.queue.size() == this.limit){
      notifyAll();
    }

    return this.queue.remove(0);
  }

}
```
    
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit). If the queue size is not equal to either bound when enqueue() or dequeue() is called, there can be no threads waiting to either enqueue or dequeue items.