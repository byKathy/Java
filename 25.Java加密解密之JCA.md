##25.1 JCA介绍
**JCA**是**Java密码系统结构**（Java Cryptography Architecture）的简称。JCA提供了一系列的用于数字签名、消息摘要（哈希）、证书管理、证书验证、加密解密（对称/非对称/流），密钥生成/管理、安全随机数等的接口。它提供了一种称为**"provider"**的方式来让开发者添加加密解密的算法实现或自定义实现，类似于插件。**provider**的好处在于：

* **算法实现独立：** 应用程序无需实现安全算法，相反地，应用程序只需要向Java平台请求安全算法服务。所有的安全算法服务使用**"provider"**方式（类似于插件）加载到JVM中，所有的安全算法都需要实现Java提供的统一标准接口，否则无法使用**"provider"**方式加载到JVM中。
* **实现互操作：** 可以实现安全算法的互操作性性，同时利于应用程序与安全算法的解耦。
* **可拓展算法：** Java平台本身内置了一系列的安全服务，如果你的应用程序需要依赖一些新兴的、尚未实现的或私有的安全服务，Java平台也提供了对应的Java接口可以让用户安装对应的算法实现。

总而言之，**provider**方式的好处在于统一Java安全服务的接口，不必要在切换不同算法实现的同时再另学一套API。当然，你也可以不基于JCA接口而直接使用提供商提供的API，例如Commons Codec或Bouncy Castle提供的API。当然地，Commons Codec和Bouncy Castle是实现了JCA接口的。这类似与JDBC接口与mysql驱动包、oracle驱动包的关系。

以下是Java8内置的安全服务，该列表位于`%JAVA_HOME%\jre\lib\java.security`文件中,安全服务对应的jar包都是位于ext目录下的。

```properties
#
# List of providers and their preference orders (see above):
#
security.provider.1=sun.security.provider.Sun
security.provider.2=sun.security.rsa.SunRsaSign
security.provider.3=sun.security.ec.SunEC
security.provider.4=com.sun.net.ssl.internal.ssl.Provider
security.provider.5=com.sun.crypto.provider.SunJCE
security.provider.6=sun.security.jgss.SunProvider
security.provider.7=com.sun.security.sasl.Provider
security.provider.8=org.jcp.xml.dsig.internal.dom.XMLDSigRI
security.provider.9=sun.security.smartcardio.SunPCSC
security.provider.10=sun.security.mscapi.SunMSCAPI
```

##25.1 JCA Concepts
This section introduces the major JCA APIs.

Engine Classes and Algorithms
An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider. The engines either provide:

cryptographic operations (encryption, digital signatures, message digests, etc.),
generators or converters of cryptographic material (keys and algorithm parameters), or
objects (keystores or certificates) that encapsulate the cryptographic data and can be used at higher layers of abstraction.
The following engine classes are available:

* SecureRandom: used to generate random or pseudo-random numbers.
* MessageDigest: used to calculate the message digest (hash) of specified data.
* Signature: initialized with keys, these are used to sign data and verify digital signatures.
* Cipher: initialized with keys, these used for encrypting/decrypting data. There are various types of algorithms: symmetric bulk encryption (e.g. AES, DES, DESede, Blowfish, IDEA), stream encryption (e.g. RC4), asymmetric encryption (e.g. RSA), and password-based encryption (PBE).
* Message Authentication Codes (MAC): like MessageDigests, these also generate hash values, but are first initialized with keys to protect the integrity of messages.
* KeyFactory: used to convert existing opaque cryptographic keys of type Key into key specifications (transparent representations of the underlying key material), and vice versa.
* SecretKeyFactory: used to convert existing opaque cryptographic keys of type SecretKey into key specifications (transparent representations of the underlying key material), and vice versa. SecretKeyFactorys are specialized KeyFactorys that create secret (symmetric) keys only.
* KeyPairGenerator: used to generate a new pair of public and private keys suitable for use with a specified algorithm.
* KeyGenerator: used to generate new secret keys for use with a specified algorithm.
* KeyAgreement: used by two or more parties to agree upon and establish a specific key to use for a particular cryptographic operation.
* AlgorithmParameters: used to store the parameters for a particular algorithm, including parameter encoding and decoding.
* AlgorithmParameterGenerator : used to generate a set of AlgorithmParameters suitable for a specified algorithm.
* KeyStore: used to create and manage a keystore. A keystore is a database of keys. Private keys in a keystore have a certificate chain associated with them, which authenticates the corresponding public key. A keystore also contains certificates from trusted entities.
* CertificateFactory: used to create public key certificates and Certificate Revocation Lists (CRLs).
* CertPathBuilder: used to build certificate chains (also known as certification paths).
* CertPathValidator: used to validate certificate chains.
* CertStore: used to retrieve Certificates and CRLs from a repository.

**NOTE:** A generator creates objects with brand-new contents, whereas a factory creates objects from existing material (for example, an encoding).

##25.2 参考资料
* http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html
* http://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html