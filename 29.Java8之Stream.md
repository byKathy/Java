#29.Java8之Stream
在动态语言中，操作集合是一个非常方便的事情。例如以下的JavaScript代码：
```JavaScript
var list = [0,1,2,3,4,5,6,7,8,9];
var rs = list.filter(function(i){return i % 2 == 0;}).map(function(i){return i * i;}).sort(function(x,y){return x < y;})
```
以上JavaScript代码执行结果为：
> [64, 36, 16, 4, 0]

而同样的功能使用Java实现的话，必须套用循环：
```Java
List<Integer> list = Arrays.asList(new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });
List<Integer> rs = new ArrayList<Integer>();
for (Integer i : list) {
	if (i % 2 == 0) {
		rs.add(i * i);
	}
}
rs.sort(new Comparator<Integer>() {
	@Override
	public int compare(Integer o1, Integer o2) {
		return o2 - o1;
	}
});
```
不难看出，相比JavaScript，Java代码显得笨重且臃肿。Oracle明显也注意到了这一点，于是在Java8中加入了对集合相应的支持。Java8并未在原有的集合类中直接支持filter、map等操作的，而是引入了一个新的类：**Stream**。使用`Stream`对集合进行操作。例如：
```JavaScript
List<Integer> list = Arrays.asList(new Integer[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
List<Integer> rs = list.stream().filter(i -> i % 2 == 0).map(i -> i * i).sorted((x,y) -> y - x).collect(Collectors.toList());
```
使用Java8新语法重构后的代码量接近JavaScript的代码，简洁性与可读性方面也有了很大的提高。当然，Java8支持的集合操作远比JavaScript多的多且更加强大。

## Stream

`Stream`提供对集合进行函数式编程操作的类。

Stream类和集合类都用于操作集合，但是Stream跟集合类存在很多不同点：

 * Stream并不是一个数据结构存储元素；它只是通过管道的方式将数据从数组、函数生成器、I/O通道中进行传输和操作；
 * 对Stream的操作并不会对产生Stream的源数据进行修改；
 * 懒惰取值（Laziness-seeking），很多Stream操作，例如filter、map、duplicate等并不会实时产生结果集。Stream的操作区分为两种：**中间操作**和**终点操作**，**中间操作**永远是懒惰取值的。这样做主要是为了性能优化。
 * Stream可能是无边界的。虽然集合是有大小限制，但Stream是不受大小限制的。短路操作，例如`limit(n)`或`findFirst()`可以从无边界的Stream中获取定长的数据。
 * 可消耗的。Stream的元素的在整个生命周期中只能被访问一次。类似于Iterator，如果想要重新访问Stream中的元素则需要重新生成Stream。

Stream可以通过多种方式获取，例如：

* Collection接口的子类可以通过`stream()`和`parallelStream()`获取；
* 数组可以通过`Arrays.stream(Object[])`获取；
* 可以通过`Stream.of(Object[])`、`IntStream.range(int, int)`或`Stream.iterate(Object,unaryOperator)`这个三个静态方法获取；
* 文件行可以通过`BufferedReader.lines()`获取；
* 指定路径的文件可以通过Files的方法获取；
* 随机数可以通过`Random.ints()`获取；
* 其他的跟获取Stream相关的方法还有`BitSet.stream`，`Pattern.splitAsStream(java.lang.Charsequence)`和`JarFile.stream（）`等。

## 流操作（Stream Operations）和管道（Pipelines）

流操作被划分为**中间操作**和**终点操作**，并且组合形成管道流。管道流由如下组合而成：数据源（例如集合，数组，函数生成器或I/O通道）；紧跟在数据源后面的是零或多个中间操作（例如Stream.filter或Stream.map）；最终操作紧跟在中间操作后面（例如Stream.forEach或Stream.reduce等）。

中间操作返回的结果是流。中间操作永远是懒惰取值的；例如Stream.filter操作实际上并没有立即执行任何过滤，取而代之的是产生一个新的流，当进行传输时就会根据**过滤谓词**对原始的数据进行过滤。只有当**终点操作**被执行时，管道的遍历才会被执行（真正执行中间操作）。

终点操作，例如Stream.forEach或IntStream.sum，会对流进行遍历并产一个结果或者副作用。当终点操作并执行完后，管道流就被消耗掉，无法再进行利用；如果需要对同样的数据进行遍历，则必须使用原始数据产生新的流。在多数情况下，终点操作被认为是饥饿的，一旦被调用，则会对数据源进行彻底的遍历直到结果被返回。最终操作中，只有`iterator()`和`spliterator()`不是饥饿的，他们被认为是**"逃生的窗口"**，可以让客户端（调用者）自由控制管道的遍历，在很多业务逻辑中，这种方式都是非常高效且常见的。

流的懒惰取值模式是非常高效的。例如在`filter-map-sum`管道操作中，filter、map和sum可以融合为一次原始数据遍历。同时，这种懒惰取值的方式，可以避免对所有的数据进行遍历，例如需求：取数组中值大于100的前十个数值。如果对整个数组都进行遍历将是毫无必要的，而且非常低效。而流的懒惰取值可避免这种低效做法（特别当流很大甚至是无限大时）。例如：`list.filter(x -> x > 100).limit(100)`。

中间操作可以进一步分解为有状态操作和无状态操作。无状态操作，如filter和map，处理当前的元素不依赖之前处理的元素，每个元素间的处理都是相互独立，互不影响的。有状态操作，如distinct和sorted，当前元素的处理依赖之前的元素。

有状态操作，可能需要对整个数据进行处理才能产生最终结果。举个例子，对流进行排序，在对整个流进行完全遍历之前是不可能产生正确结果的。As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data. Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering.

此外，有些操作被认为是**短路操作**。在中间操作过程中，当输入是无限，而却需要有限流的输出时，则该中间操作被认为是短路操作；在终点操作过程中，当输入是无限，切需要在有限的时间终止操作时，则该操作被认为是短路操作。Having a short-circuiting operation in the pipeline is a necessary, but not sufficient, condition for the processing of an infinite stream to terminate normally in finite time.

## 并行（Parallelism）
使用循环对元素进行处理本质上来说是串行的。Stream通过对管道的聚合操作进行重构处理使流的并行计算变得更加容易实现，而不是简简单单地对每个元素进行迭代处理。所有的流操作都可以选择使用串行模式或并行模式中进行处理。例如，Collection类有Collection.stream()和Collection.parallelStream()两个方法分别对应**串行流**和**并行流**。再如IntStream.range(int,int)产出串行流，但是可以通过调用BaseStream.parallel()方法可以产生并行流。

如下例子分别使用串行和并行计算widgets的weigh总和：

```Java
// 串行计算
int sumOfWeights = widgets.stream()
                               .filter(b -> b.getColor() == RED)
                               .mapToInt(b -> b.getWeight())
                               .sum();

// 并行计算
int sumOfWeights = widgets.parallelStream()
                               .filter(b -> b.getColor() == RED)
                               .mapToInt(b -> b.getWeight())
                               .sum();
```
两种方式最大的不同在于一个调用stream()，一个调用parallelStream()。当最终操作被执行时，流操作使用串行或并行决定于调用它的流是Stream或parallelStream。可以根据流的isParallel()方法判断当前流是否支持并行操作，以此同时，可以通过修改BaseStream.sequential()和BaseStream.parallel()操作来修改当前流是否支持并行。

除了某些操作具有明确的不确定性（例如findAndy()）之外，流的操作是串行或并行并不会影响到最终的结果。

大部分的流操作都接受参数用于实现用户自定义行为，很多情况下都会使用lambdas表达式进行传参。为了保证正确的处理逻辑，这一些参数必须是互不干扰的，很多时候，这些参数也是无状态的。这些参数通常是**函数式接口**，例如Function接口、lambdas表达式或方法引用。

## 自定义实现

## 参考资料
 * 翻译自：http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
