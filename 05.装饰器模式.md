#05.装饰器模式

## 遇到的问题

  学习的最好方法就是实践，想当年大学学《设计模式》这门课的时候，重修两次，补考还挂了两次，最后还是甩小聪明才拿到的毕业证。
往事不多提，甚是可悲。

  最近遇到一个问题，这里有一个controller的方法，方法里面需要获取request header的x-forwarded-for属性的值：
  
```java
@RequestMapping(value = "/")
public void method(HttpServletRequest request,HttpServletResponse response) {
    String remoteAddr = request.getHeader("x-forwarded-for");
}
```

  问题是，在不修改现有代码的情况下，如何修改request.getHeader("x-forwarded-for")这个方法的返回值，即在当x-forward-for为空的情况下，指定一个默认值。
  
  自然而然地，我们会想到使用filter来改变request.getHeader("x-forward-for")的行为。于是乎：
  
```java
@WebFilter("/*")
public class MyFilter implements Filter {

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
		
        // 代码实现
        chain.doFilter(request, response);
    }

    // 省略....

}
```

  写到这里有点蒙了，request并不提供修改header的方法（也就是request.setHeader(key,value)），那怎么修改controller的getHeader方法的返回值呢？
  
  或者我们可以换一种思路，chain.doFilter(request, response)会往下传递request和response，我们能不能伪装一个request，从而改变其行为呢。
  
  那问题就变得简单了：如何伪装这个request对象?


##  伪装request
  
  重新写一个类（称为wrapper）实现HttpServletRequest接口，并实现其所有方法，由于wrapper并不知道request的行为，所以使用构造方法将真实的request传入，在具体实现的时候，调用真实的request实现。

```java
public class MyHttpServletRequestWrapper implements HttpServletRequest {
    private HttpServletRequest request;

    public MyHttpServletRequestWrapper(ServletRequest request) {
        this.request = (HttpServletRequest) request;
    }

    @Override
    public AsyncContext getAsyncContext() {
        return this.getAsyncContext();
    }
    
    @Override
    public String getHeader(String key) {
    	// 如果x-forwarded-for为空，则指定默认值
    	if(key.equals("x-forwarded-for") && this.getHeader == null) {
    	    return "172.16.1.1";
    	}
        return this.getHeader(key);
    }
    
    // ... 省略其他方法的实现
}
```

  由于重新实现了getHeader(String key)的实现，在原来的基础上包装了一下，从而改变了getHeader的行为。我们我们在MyFilte就可以这样使用了：
  
```
public void doFilter(ServletRequest request, ServletResponse response,
        FilterChain chain) throws IOException, ServletException {
		
    MyHttpServletRequestWrapper requestWrapper = new MyHttpServletRequestWrapper(request); // 装饰request

    chain.doFilter(requestWrapper, response); // 传递的是包装后的request
}
```

 以上的代码可以按照我们的设想正确地执行，这就是装饰器模式。
 
 不过在实际的项目中不必要全部重写HttpServletRequest方法，我们可以使用现成的HttpServletRequestWrapper类。它的实现方法就是采用了装饰器模式。
  	
