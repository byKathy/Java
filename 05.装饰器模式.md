#05.装饰器模式

## 遇到的问题

  学习的最好方法就是实践，想当年大学学《设计模式》这门课的时候，重修两次，补考还挂了两次，最后还是甩小聪明才拿到的毕业证。
往事不多提，甚是可悲。

  最近遇到一个问题，这里有一个controller的方法，方法里面需要获取request header的 __x-forwarded-for__ 属性的值：
  
```java
@RequestMapping(value = "/")
public void method(HttpServletRequest request,HttpServletResponse response) {
    String remoteAddr = request.getHeader("x-forwarded-for");
}
```

  问题是，在不修改现有代码的情况下，如何修改request.getHeader("x-forwarded-for")这个方法的返回值，即在当x-forward-for为空的情况下，指定一个默认值。
  
  自然而然地，我们会想到使用filter来改变 __request.getHeader("x-forward-for")__ 的行为。于是乎：
  
```java
@WebFilter("/*")
public class MyFilter implements Filter {

    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
		
        // 代码实现
        chain.doFilter(request, response);
    }

    // 省略....

}
```

  写到这里有点蒙了，request并不提供修改header的方法（也就是request.setHeader(key,value)），那怎么修改controller的getHeader方法的返回值呢？
  
  或者我们可以换一种思路，<code>chain.doFilter(request, response)</code>会往下传递request和response，我们能不能伪装一个request，从而改变其行为呢。
  
  那问题就变得简单了：如何伪装这个request对象?


##  伪装request
  
  重新写一个类（称为wrapper）实现HttpServletRequest接口，并实现其所有方法，由于wrapper并不知道request的行为，所以使用构造方法将真实的request传入，在具体实现的时候，调用真实的request实现。

```java
public class MyHttpServletRequestWrapper implements HttpServletRequest {
    private HttpServletRequest request;

    public MyHttpServletRequestWrapper(ServletRequest request) {
        this.request = (HttpServletRequest) request;
    }

    @Override
    public AsyncContext getAsyncContext() {
        return this.getAsyncContext();
    }
    
    @Override
    public String getHeader(String key) {
    	// 如果x-forwarded-for为空，则指定默认值
    	if(key.equals("x-forwarded-for") && this.getHeader == null) {
    	    return "172.16.1.1";
    	}
        return this.getHeader(key);
    }
    
    // ... 省略其他方法的实现
}
```

  由于重新实现了getHeader(String key)的实现，在原来的基础上包装了一下，从而改变了getHeader的行为。我们我们在MyFilte就可以这样使用了：
  
```java
public void doFilter(ServletRequest request, ServletResponse response,
        FilterChain chain) throws IOException, ServletException {
		
    MyHttpServletRequestWrapper requestWrapper = new MyHttpServletRequestWrapper(request); // 装饰request

    chain.doFilter(requestWrapper, response); // 传递的是包装后的request
}
```

 以上的代码可以按照我们的设想正确地执行，这就是 __装饰器模式__ 。


##该死的需求

 之前已经实现了修改getHeader("x-forwded-for")的行为，现在改一下需求，要求增加一个paramater参数[csrftoken]，而且这个实现跟之前的不互相影响。
ok，重新下类，实现HttpServletRequest的所有方法，然后修改getParamater方法：

```java
@Override
public String getParameter(String name) {
    // 如果x-forwarded-for为空，则指定默认值
    if(name.equals("csrftoken")) {
        return "123456789";
    }
    return this.getParameter(key);
}
```

 然后再增加一个header参数、或者在某个方法执行前后加入一些代码......
 
 问题出来了，为了修改目标对象的行为，每次我们都需要继承他，实现他的M-1个方法，再去修改他的一个目标方法，貌似，为了实现修改某个方法的行为，
从而增加N个类，然后重写他的M-1个方法，貌似很浪费。有没有更加灵活的方法呢： __不用新增那么多类，也不用重写覆盖多余的方法__ 。

 我们分析一下问题的原因：
 
 1. 增加的类过多：我们可以考虑使用匿名内部类实现。
 2. 重写覆盖了多余的方法，原因是我们实现的是Interface接口，而Interface里所有的方法都必须实现：
 那么我们可以考虑使用一个中间类来实现接口，然后我们再继承中间类，从而也可以按需覆盖目标方法了。
 
 
  	
