#01.锁

##不要在可重用的对象上加锁

不要在可重用的对象上加锁，如果你这样做了，可能导致死锁或其他不可预测的行为。

####不合规的代码（Boolean类型锁）

下面的代码在Boolean类型上加锁：

```Java
private final Boolean lock= Boolean.FALSE;
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
```

Boolean类型对象并不适合加锁，因为它只有两个值：`true`和`false`。在JVM中，Boolean类型的两个字面量值都分别都指向同一个共享对象。在这里例子中，lock指向JVM中的一个Boolean.FALSE实例，而这个实例的所有线程共享的。如果有其他的线程不注意地也使用了Boolean.FALSE进行加锁，就可能导致死锁或不可预测的行为。

####不合规的代码示例（Integer的自动装箱）

这个例子中的不合规代码在自动装箱的Integer类型上加锁：

```Java
private int = 0;
private final Integer lock = count; // Boxed primitive lock is shared
public void doSomething() {
  synchronized (lock) {
    count++;
    // ...
  }
}
```

自动装箱的Integer对象，在一定范围内是共享的（ 这个范围是-128到127），因此，这会导致跟Boolean常量一样的问题。JVM的常量池中缓存了Integer(-128)到Integer(127)这个范围的Integer对象，在这个范围内的自动装箱Integer对象，都是从这个常量池中共享这些对象。有一些JVM实现也允许大于这个范围的Integer常量池。所以，在自动装箱的对象上加锁是不安全的。而使用`new Integer(value)`创建的Integer实例对象是不共享的。**一般来说，在自动装箱的数据类型上加锁都是不可取和不安全的。**

####解决方案（Integer）

上面例子的解决方法就是在非装箱的Integer对象上加锁。如下面的代码所示：

```Java
private int count = 0;
private final Integer lock = new Integer(count);
 
public void doSomething() {
  synchronized (lock) {
    count++;
    // ...
  }
}
```
当使用构造方法时，会创建独立的Integer对象，而不会使用常量池中共享的Intege对象。这是一个可接受的解决方法，但这会导致维护问题，开发人员会错误地认为使用自动装箱的Integer也是可以的。更好的解决方法就是`new Object()`对象，最后一个例子会详细介绍。

####不合规的代码示例（new String("lock").intern()）

下面是一个不合规的代码示例：

```Java
private final String lock = new String("LOCK").intern();
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
```

Java API对java.lang.String类的inern()方法解释如下：

>When the intern() method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.

Consequently, an interned String object behaves like a global variable in the JVM. As demonstrated in this noncompliant code example, even when every instance of an object maintains its own lock field, the fields all refer to a common String constant. Locking on String constants has the same reuse problem as locking on Boolean constants.
Additionally, hostile code from any other package can exploit this vulnerability, if the class is accessible. See rule LCK00-J. Use private final lock objects to synchronize classes that may interact with untrusted code for more information.
Noncompliant Code Example (String Literal)
This noncompliant code example locks on a final String literal.
// This bug was found in jetty-6.1.3 BoundedThreadPool
private final String lock = "LOCK";
 
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
String literals are constant and are automatically interned. Consequently, this example suffers from the same pitfalls as the preceding noncompliant code example.
Compliant Solution (String Instance)
This compliant solution locks on a noninterned String instance.
private final String lock = new String("LOCK");
 
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
A String instance differs from a String literal. The instance has a unique reference and its own intrinsic lock that is distinct from other String object instances or literals. Nevertheless, a better approach is to synchronize on a private final lock object, as shown in the following compliant solution.
Compliant Solution (Private Final Lock Object)
This compliant solution synchronizes on a private final lock object. This is one of the few cases in which a java.lang.Object instance is useful.
private final Object lock = new Object();
 
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
For more information on using an Object as a lock, see rule LCK00-J. Use private final lock objects to synchronize classes that may interact with untrusted code.
Risk Assessment
A significant number of concurrency vulnerabilities arise from locking on the wrong kind of object. It is important to consider the properties of the lock object rather than simply scavenging for objects on which to synchronize.
Rule
Severity
Likelihood
Remediation Cost
Priority
Level
LCK01-J
medium
probable
medium
P8
L2
Automated Detection
Some static analysis tools can detect violations of this rule.
Tool
Version
Checker
Description
ThreadSafe	1.3	
CCE_CC_REUSEDOBJ_SYNC
Implemented
Bibliography
[API 2006]
Class String, Collections
[Findbugs 2008]
 
[Miller 2009]
Locking
[Pugh 2008]
Synchronization
[Tutorials 2008]
Wrapper Implementations


----------


 